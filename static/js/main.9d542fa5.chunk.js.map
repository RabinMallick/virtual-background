{"version":3,"sources":["core/helpers/segmentationHelper.ts","pipelines/canvas2d/canvas2dPipeline.ts","pipelines/helpers/webglHelper.ts","pipelines/webgl2/backgroundBlurStage.ts","pipelines/webgl2/resizingStage.ts","pipelines/webgl2/webgl2Pipeline.ts","pipelines/webgl2/softmaxStage.ts","pipelines/webgl2/loadSegmentationStage.ts","pipelines/webgl2/jointBilateralFilterStage.ts","pipelines/webgl2/backgroundImageStage.ts","core/hooks/useRenderingPipeline.ts","core/components/OutputViewer.tsx","core/components/SourceViewer.tsx","core/components/ViewerCard.tsx","core/helpers/backgroundHelper.ts","core/hooks/useBodyPix.ts","core/hooks/useTFLite.ts","App.tsx","reportWebVitals.ts","index.tsx"],"names":["inputResolutions","getTFLiteModelFileName","model","inputResolution","Error","buildCanvas2dPipeline","sourcePlayback","backgroundConfig","segmentationConfig","canvas","bodyPix","tflite","addFrameEvent","ctx","getContext","segmentationWidth","segmentationHeight","segmentationPixelCount","segmentationMask","ImageData","segmentationMaskCanvas","document","createElement","width","height","postProcessingConfig","segmentationMaskCtx","inputMemoryOffset","_getInputMemoryOffset","outputMemoryOffset","_getOutputMemoryOffset","a","type","resizeSource","runBodyPixInference","runTFLiteInference","runPostProcessing","drawImage","htmlElement","imageData","getImageData","i","HEAPF32","data","segmentPerson","segmentation","console","log","putImageData","_runInference","background","person","shift","Math","max","backgroundExp","exp","personExp","globalCompositeOperation","filter","smoothSegmentationMask","render","updatePostProcessingConfig","newPostProcessingConfig","cleanUp","glsl","String","raw","createPiplelineStageProgram","gl","vertexShader","fragmentShader","positionBuffer","texCoordBuffer","program","createProgram","attachShader","linkProgram","getProgramParameter","LINK_STATUS","getProgramInfoLog","positionAttributeLocation","getAttribLocation","enableVertexAttribArray","bindBuffer","ARRAY_BUFFER","vertexAttribPointer","FLOAT","texCoordAttributeLocation","compileShader","shaderType","shaderSource","shader","createShader","getShaderParameter","COMPILE_STATUS","getShaderInfoLog","createTexture","internalformat","minFilter","NEAREST","magFilter","texture","bindTexture","TEXTURE_2D","texParameteri","TEXTURE_WRAP_S","CLAMP_TO_EDGE","TEXTURE_WRAP_T","TEXTURE_MIN_FILTER","TEXTURE_MAG_FILTER","texStorage2D","x","y","format","dest","buf","createBuffer","PIXEL_PACK_BUFFER","bufferData","byteLength","STREAM_READ","readPixels","getBufferSubDataAsync","deleteBuffer","target","buffer","srcByteOffset","dstBuffer","dstOffset","length","sync","fenceSync","SYNC_GPU_COMMANDS_COMPLETE","flush","clientWaitAsync","res","deleteSync","WAIT_FAILED","getBufferSubData","Promise","resolve","requestAnimationFrame","test","clientWaitSync","TIMEOUT_EXPIRED","buildBackgroundBlurStage","personMaskTexture","blurPass","fragmentShaderSource","scale","outputWidth","outputHeight","texelWidth","texelHeight","FRAGMENT_SHADER","inputFrameLocation","getUniformLocation","personMaskLocation","texelSizeLocation","texture1","RGBA8","LINEAR","texture2","frameBuffer1","createFramebuffer","bindFramebuffer","FRAMEBUFFER","framebufferTexture2D","COLOR_ATTACHMENT0","frameBuffer2","viewport","useProgram","uniform1i","activeTexture","TEXTURE1","uniform2f","drawArrays","TRIANGLE_STRIP","TEXTURE2","deleteFramebuffer","deleteTexture","deleteProgram","deleteShader","buildBlurPass","blendPass","vertexShaderSource","VERTEX_SHADER","blurredInputFrame","coverageLocation","updateCoverage","coverage","buildBlendPass","buildResizingStage","tfliteInputMemoryOffset","outputPixelCount","outputTexture","frameBuffer","outputPixels","Uint8Array","readPixelsAsync","RGBA","UNSIGNED_BYTE","tfliteIndex","outputIndex","buildWebGL2Pipeline","backgroundImage","frameWidth","frameHeight","vertexArray","createVertexArray","bindVertexArray","Float32Array","STATIC_DRAW","inputFrameTexture","segmentationTexture","resizingStage","loadSegmentationStage","tfliteOutputMemoryOffset","inputLocation","inputTexture","RG32F","texSubImage2D","RG","buildSoftmaxStage","R32F","RED","buildLoadSegmentationStage","jointBilateralFilterStage","segmentationMaskLocation","stepLocation","radiusLocation","offsetLocation","sigmaTexelLocation","sigmaColorLocation","updateSigmaSpace","sigmaSpace","step","sqrt","radius","offset","sigmaTexel","uniform1f","updateSigmaColor","sigmaColor","buildJointBilateralFilterStage","backgroundStage","outputRatio","backgroundScaleLocation","backgroundOffsetLocation","backgroundLocation","lightWrappingLocation","blendModeLocation","backgroundTexture","updateBackgroundImage","naturalWidth","naturalHeight","xOffset","yOffset","backgroundWidth","backgroundHeight","xScale","yScale","complete","onload","updateLightWrapping","lightWrapping","updateBlendMode","blendMode","buildBackgroundImageStage","clearColor","clear","COLOR_BUFFER_BIT","TEXTURE0","texImage2D","jointBilateralFilter","backgroundImageStage","deleteVertexArray","useRenderingPipeline","useState","pipeline","setPipeline","backgroundImageRef","useRef","canvasRef","fps","setFps","durations","setDurations","useEffect","renderRequestId","shouldRender","previousTime","beginTime","eventCount","frameCount","frameDurations","newPipeline","current","beginFrame","endFrame","Date","now","time","cancelAnimationFrame","useStyles","makeStyles","theme","createStyles","root","flex","position","objectFit","stats","top","right","left","textAlign","backgroundColor","color","palette","common","white","OutputViewer","props","classes","resizingDuration","inferenceDuration","postProcessingDuration","statDetails","round","join","React","setImgSrc","useCallback","getElementById","imgSrc","toDataURL","style","className","ref","src","url","alt","hidden","id","Button","variant","display","justifyContent","alignItems","breakpoints","down","overflow","up","borderRightWidth","borderRightStyle","borderRightColor","divider","SourceViewer","sourceUrl","setSourceUrl","isLoading","setLoading","isCameraError","setCameraError","videoRef","undefined","setTimeout","sourceConfig","constraint","video","navigator","mediaDevices","getUserMedia","stream","srcObject","error","getCameraStream","CircularProgress","onLoad","event","image","fontSize","autoPlay","playsInline","controls","muted","loop","onLoadedData","videoWidth","videoHeight","minHeight","spacing","gridColumnStart","gridColumnEnd","gridRowStart","gridRowEnd","noOutput","avatar","ViewerCard","setSourcePlayback","Paper","Avatar","backgroundImageUrls","map","imageName","process","useBodyPix","setBodyPix","tf","tfBodyPix","loadBodyPix","useTFLite","setTFLite","tfliteSIMD","setTFLiteSIMD","selectedTFLite","setSelectedTFLite","isSIMDSupported","setSIMDSupported","createTFLiteModule","then","createTFLiteSIMDModule","createdTFLiteSIMD","warn","loadTFLite","backend","newSelectedTFLite","modelFileName","fetch","modelResponse","arrayBuffer","modelBufferOffset","_getModelBufferMemoryOffset","HEAPU8","set","_loadModel","_getInputHeight","_getInputWidth","_getInputChannelCount","_getOutputHeight","_getOutputWidth","_getOutputChannelCount","loadTFLiteModel","margin","gap","gridTemplateColumns","resourceSelectionCards","flexDirection","App","setSegmentationConfig","previousSegmentationConfig","reportWebVitals","onPerfEntry","Function","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","StrictMode","CssBaseline"],"mappings":"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","file":"static/js/main.9d542fa5.chunk.js","sourcesContent":["export type SegmentationModel = 'bodyPix' | 'meet' | 'mlkit'\nexport type SegmentationBackend = 'webgl' | 'wasm' | 'wasmSimd'\nexport type InputResolution = '640x360' | '256x256' | '256x144' | '160x96'\n\nexport const inputResolutions: {\n  [resolution in InputResolution]: [number, number]\n} = {\n  '640x360': [640, 360],\n  '256x256': [256, 256],\n  '256x144': [256, 144],\n  '160x96': [160, 96],\n}\n\nexport type PipelineName = 'canvas2dCpu' | 'webgl2'\n\nexport type SegmentationConfig = {\n  model: SegmentationModel\n  backend: SegmentationBackend\n  inputResolution: InputResolution\n  pipeline: PipelineName\n}\n\nexport function getTFLiteModelFileName(\n  model: SegmentationModel,\n  inputResolution: InputResolution\n) {\n  switch (model) {\n    case 'meet':\n      return inputResolution === '256x144' ? 'segm_full_v679' : 'segm_lite_v681'\n\n    case 'mlkit':\n      return 'selfiesegmentation_mlkit-256x256-2021_01_19-v1215.f16'\n\n    default:\n      throw new Error(`No TFLite file for this segmentation model: ${model}`)\n  }\n}\n","import { BodyPix } from '@tensorflow-models/body-pix'\nimport { BackgroundConfig } from '../../core/helpers/backgroundHelper'\nimport { PostProcessingConfig } from '../../core/helpers/postProcessingHelper'\nimport {\n  inputResolutions,\n  SegmentationConfig\n} from '../../core/helpers/segmentationHelper'\nimport { SourcePlayback } from '../../core/helpers/sourceHelper'\nimport { TFLite } from '../../core/hooks/useTFLite'\n\nexport function buildCanvas2dPipeline(\n  sourcePlayback: SourcePlayback,\n  backgroundConfig: BackgroundConfig,\n  segmentationConfig: SegmentationConfig,\n  canvas: HTMLCanvasElement,\n  bodyPix: BodyPix,\n  tflite: TFLite,\n  addFrameEvent: () => void\n) {\n  const ctx = canvas.getContext('2d')!\n\n  const [segmentationWidth, segmentationHeight] = inputResolutions[\n    segmentationConfig.inputResolution\n  ]\n  const segmentationPixelCount = segmentationWidth * segmentationHeight\n  const segmentationMask = new ImageData(segmentationWidth, segmentationHeight)\n  const segmentationMaskCanvas = document.createElement('canvas')\n  segmentationMaskCanvas.width = segmentationWidth\n  segmentationMaskCanvas.height = segmentationHeight\n  const segmentationMaskCtx = segmentationMaskCanvas.getContext('2d')!\n\n  const inputMemoryOffset = tflite._getInputMemoryOffset() / 4\n  const outputMemoryOffset = tflite._getOutputMemoryOffset() / 4\n\n  let postProcessingConfig: PostProcessingConfig\n\n  async function render() {\n    if (backgroundConfig.type !== 'none') {\n      resizeSource()\n    }\n\n    addFrameEvent()\n\n    if (backgroundConfig.type !== 'none') {\n      if (segmentationConfig.model === 'bodyPix') {\n        await runBodyPixInference()\n      } else {\n        runTFLiteInference()\n      }\n    }\n\n    addFrameEvent()\n\n    runPostProcessing()\n  }\n\n  function updatePostProcessingConfig(\n    newPostProcessingConfig: PostProcessingConfig\n  ) {\n    postProcessingConfig = newPostProcessingConfig\n  }\n\n  function cleanUp() {\n    // Nothing to clean up in this rendering pipeline\n  }\n\n  function resizeSource() {\n    segmentationMaskCtx.drawImage(\n      sourcePlayback.htmlElement,\n      0,\n      0,\n      sourcePlayback.width,\n      sourcePlayback.height,\n      0,\n      0,\n      segmentationWidth,\n      segmentationHeight\n    )\n\n    if (\n      segmentationConfig.model === 'meet' ||\n      segmentationConfig.model === 'mlkit'\n    ) {\n      const imageData = segmentationMaskCtx.getImageData(\n        0,\n        0,\n        segmentationWidth,\n        segmentationHeight\n      )\n\n      for (let i = 0; i < segmentationPixelCount; i++) {\n        tflite.HEAPF32[inputMemoryOffset + i * 3] = imageData.data[i * 4] / 255\n        tflite.HEAPF32[inputMemoryOffset + i * 3 + 1] =\n          imageData.data[i * 4 + 1] / 255\n        tflite.HEAPF32[inputMemoryOffset + i * 3 + 2] =\n          imageData.data[i * 4 + 2] / 255\n      }\n    }\n  }\n\n  async function runBodyPixInference() {\n    const segmentation = await bodyPix.segmentPerson(segmentationMaskCanvas)\n    console.log(segmentation)\n    console.log(\"Called\")\n    for (let i = 0; i < segmentationPixelCount; i++) {\n      // Sets only the alpha component of each pixel\n      segmentationMask.data[i * 4 + 3] = segmentation.data[i] ? 255 : 0\n    }\n    segmentationMaskCtx.putImageData(segmentationMask, 0, 0)\n  }\n\n  function runTFLiteInference() {\n    tflite._runInference()\n\n    for (let i = 0; i < segmentationPixelCount; i++) {\n      if (segmentationConfig.model === 'meet') {\n        const background = tflite.HEAPF32[outputMemoryOffset + i * 2]\n        const person = tflite.HEAPF32[outputMemoryOffset + i * 2 + 1]\n        const shift = Math.max(background, person)\n        const backgroundExp = Math.exp(background - shift)\n        const personExp = Math.exp(person - shift)\n\n        // Sets only the alpha component of each pixel\n        segmentationMask.data[i * 4 + 3] =\n          (255 * personExp) / (backgroundExp + personExp) // softmax\n      } else if (segmentationConfig.model === 'mlkit') {\n        const person = tflite.HEAPF32[outputMemoryOffset + i]\n        segmentationMask.data[i * 4 + 3] = 255 * person\n      }\n    }\n    segmentationMaskCtx.putImageData(segmentationMask, 0, 0)\n  }\n\n  function runPostProcessing() {\n    ctx.globalCompositeOperation = 'copy'\n    ctx.filter = 'none'\n\n    if (postProcessingConfig?.smoothSegmentationMask) {\n      if (backgroundConfig.type === 'blur') {\n        ctx.filter = 'blur(8px)' // FIXME Does not work on Safari\n      } else if (backgroundConfig.type === 'image') {\n        ctx.filter = 'blur(4px)' // FIXME Does not work on Safari\n      }\n    }\n\n    if (backgroundConfig.type !== 'none') {\n      drawSegmentationMask()\n      ctx.globalCompositeOperation = 'source-in'\n      ctx.filter = 'none'\n    }\n\n    ctx.drawImage(sourcePlayback.htmlElement, 0, 0)\n\n    if (backgroundConfig.type === 'blur') {\n      blurBackground()\n    }\n  }\n\n  function drawSegmentationMask() {\n    ctx.drawImage(\n      segmentationMaskCanvas,\n      0,\n      0,\n      segmentationWidth,\n      segmentationHeight,\n      0,\n      0,\n      sourcePlayback.width,\n      sourcePlayback.height\n    )\n  }\n\n  function blurBackground() {\n    ctx.globalCompositeOperation = 'destination-over'\n    ctx.filter = 'blur(8px)' // FIXME Does not work on Safari\n    ctx.drawImage(sourcePlayback.htmlElement, 0, 0)\n  }\n\n  return { render, updatePostProcessingConfig, cleanUp }\n}\n","/**\n * Use it along with boyswan.glsl-literal VSCode extension\n * to get GLSL syntax highlighting.\n * https://marketplace.visualstudio.com/items?itemName=boyswan.glsl-literal\n *\n * On VSCode OSS, boyswan.glsl-literal requires slevesque.shader extension\n * to be installed as well.\n * https://marketplace.visualstudio.com/items?itemName=slevesque.shader\n */\nexport const glsl = String.raw\n\nexport function createPiplelineStageProgram(\n  gl: WebGL2RenderingContext,\n  vertexShader: WebGLShader,\n  fragmentShader: WebGLShader,\n  positionBuffer: WebGLBuffer,\n  texCoordBuffer: WebGLBuffer\n) {\n  const program = createProgram(gl, vertexShader, fragmentShader)\n\n  const positionAttributeLocation = gl.getAttribLocation(program, 'a_position')\n  gl.enableVertexAttribArray(positionAttributeLocation)\n  gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer)\n  gl.vertexAttribPointer(positionAttributeLocation, 2, gl.FLOAT, false, 0, 0)\n\n  const texCoordAttributeLocation = gl.getAttribLocation(program, 'a_texCoord')\n  gl.enableVertexAttribArray(texCoordAttributeLocation)\n  gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer)\n  gl.vertexAttribPointer(texCoordAttributeLocation, 2, gl.FLOAT, false, 0, 0)\n\n  return program\n}\n\nexport function createProgram(\n  gl: WebGL2RenderingContext,\n  vertexShader: WebGLShader,\n  fragmentShader: WebGLShader\n) {\n  const program = gl.createProgram()!\n  gl.attachShader(program, vertexShader)\n  gl.attachShader(program, fragmentShader)\n  gl.linkProgram(program)\n  if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\n    throw new Error(\n      `Could not link WebGL program: ${gl.getProgramInfoLog(program)}`\n    )\n  }\n  return program\n}\n\nexport function compileShader(\n  gl: WebGL2RenderingContext,\n  shaderType: number,\n  shaderSource: string\n) {\n  const shader = gl.createShader(shaderType)!\n  gl.shaderSource(shader, shaderSource)\n  gl.compileShader(shader)\n  if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\n    throw new Error(`Could not compile shader: ${gl.getShaderInfoLog(shader)}`)\n  }\n  return shader\n}\n\nexport function createTexture(\n  gl: WebGL2RenderingContext,\n  internalformat: number,\n  width: number,\n  height: number,\n  minFilter = gl.NEAREST,\n  magFilter = gl.NEAREST\n) {\n  const texture = gl.createTexture()\n  gl.bindTexture(gl.TEXTURE_2D, texture)\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE)\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE)\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, minFilter)\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, magFilter)\n  gl.texStorage2D(gl.TEXTURE_2D, 1, internalformat, width, height)\n  return texture\n}\n\nexport async function readPixelsAsync(\n  gl: WebGL2RenderingContext,\n  x: number,\n  y: number,\n  width: number,\n  height: number,\n  format: number,\n  type: number,\n  dest: ArrayBufferView\n) {\n  const buf = gl.createBuffer()!\n  gl.bindBuffer(gl.PIXEL_PACK_BUFFER, buf)\n  gl.bufferData(gl.PIXEL_PACK_BUFFER, dest.byteLength, gl.STREAM_READ)\n  gl.readPixels(x, y, width, height, format, type, 0)\n  gl.bindBuffer(gl.PIXEL_PACK_BUFFER, null)\n\n  await getBufferSubDataAsync(gl, gl.PIXEL_PACK_BUFFER, buf, 0, dest)\n\n  gl.deleteBuffer(buf)\n  return dest\n}\n\nasync function getBufferSubDataAsync(\n  gl: WebGL2RenderingContext,\n  target: number,\n  buffer: WebGLBuffer,\n  srcByteOffset: number,\n  dstBuffer: ArrayBufferView,\n  dstOffset?: number,\n  length?: number\n) {\n  const sync = gl.fenceSync(gl.SYNC_GPU_COMMANDS_COMPLETE, 0)!\n  gl.flush()\n  const res = await clientWaitAsync(gl, sync)\n  gl.deleteSync(sync)\n\n  if (res !== gl.WAIT_FAILED) {\n    gl.bindBuffer(target, buffer)\n    gl.getBufferSubData(target, srcByteOffset, dstBuffer, dstOffset, length)\n    gl.bindBuffer(target, null)\n  }\n}\n\nfunction clientWaitAsync(gl: WebGL2RenderingContext, sync: WebGLSync) {\n  return new Promise<number>((resolve) => {\n    function test() {\n      const res = gl.clientWaitSync(sync, 0, 0)\n      if (res === gl.WAIT_FAILED) {\n        resolve(res)\n        return\n      }\n      if (res === gl.TIMEOUT_EXPIRED) {\n        requestAnimationFrame(test)\n        return\n      }\n      resolve(res)\n    }\n    requestAnimationFrame(test)\n  })\n}\n","import {\n  compileShader,\n  createPiplelineStageProgram,\n  createTexture,\n  glsl,\n} from '../helpers/webglHelper'\n\nexport type BackgroundBlurStage = {\n  render(): void\n  updateCoverage(coverage: [number, number]): void\n  cleanUp(): void\n}\n\nexport function buildBackgroundBlurStage(\n  gl: WebGL2RenderingContext,\n  vertexShader: WebGLShader,\n  positionBuffer: WebGLBuffer,\n  texCoordBuffer: WebGLBuffer,\n  personMaskTexture: WebGLTexture,\n  canvas: HTMLCanvasElement\n): BackgroundBlurStage {\n  const blurPass = buildBlurPass(\n    gl,\n    vertexShader,\n    positionBuffer,\n    texCoordBuffer,\n    personMaskTexture,\n    canvas\n  )\n  const blendPass = buildBlendPass(gl, positionBuffer, texCoordBuffer, canvas)\n\n  function render() {\n    blurPass.render()\n    blendPass.render()\n  }\n\n  function updateCoverage(coverage: [number, number]) {\n    blendPass.updateCoverage(coverage)\n  }\n\n  function cleanUp() {\n    blendPass.cleanUp()\n    blurPass.cleanUp()\n  }\n\n  return {\n    render,\n    updateCoverage,\n    cleanUp,\n  }\n}\n\nfunction buildBlurPass(\n  gl: WebGL2RenderingContext,\n  vertexShader: WebGLShader,\n  positionBuffer: WebGLBuffer,\n  texCoordBuffer: WebGLBuffer,\n  personMaskTexture: WebGLTexture,\n  canvas: HTMLCanvasElement\n) {\n  const fragmentShaderSource = glsl`#version 300 es\n\n    precision highp float;\n\n    uniform sampler2D u_inputFrame;\n    uniform sampler2D u_personMask;\n    uniform vec2 u_texelSize;\n\n    in vec2 v_texCoord;\n\n    out vec4 outColor;\n\n    const float offset[5] = float[](0.0, 1.0, 2.0, 3.0, 4.0);\n    const float weight[5] = float[](0.2270270270, 0.1945945946, 0.1216216216,\n      0.0540540541, 0.0162162162);\n\n    void main() {\n      vec4 centerColor = texture(u_inputFrame, v_texCoord);\n      float personMask = texture(u_personMask, v_texCoord).a;\n\n      vec4 frameColor = centerColor * weight[0] * (1.0 - personMask);\n\n      for (int i = 1; i < 5; i++) {\n        vec2 offset = vec2(offset[i]) * u_texelSize;\n\n        vec2 texCoord = v_texCoord + offset;\n        frameColor += texture(u_inputFrame, texCoord) * weight[i] *\n          (1.0 - texture(u_personMask, texCoord).a);\n\n        texCoord = v_texCoord - offset;\n        frameColor += texture(u_inputFrame, texCoord) * weight[i] *\n          (1.0 - texture(u_personMask, texCoord).a);\n      }\n      outColor = vec4(frameColor.rgb + (1.0 - frameColor.a) * centerColor.rgb, 1.0);\n    }\n  `\n\n  const scale = 0.5\n  const outputWidth = canvas.width * scale\n  const outputHeight = canvas.height * scale\n  const texelWidth = 1 / outputWidth\n  const texelHeight = 1 / outputHeight\n\n  const fragmentShader = compileShader(\n    gl,\n    gl.FRAGMENT_SHADER,\n    fragmentShaderSource\n  )\n  const program = createPiplelineStageProgram(\n    gl,\n    vertexShader,\n    fragmentShader,\n    positionBuffer,\n    texCoordBuffer\n  )\n  const inputFrameLocation = gl.getUniformLocation(program, 'u_inputFrame')\n  const personMaskLocation = gl.getUniformLocation(program, 'u_personMask')\n  const texelSizeLocation = gl.getUniformLocation(program, 'u_texelSize')\n  const texture1 = createTexture(\n    gl,\n    gl.RGBA8,\n    outputWidth,\n    outputHeight,\n    gl.NEAREST,\n    gl.LINEAR\n  )\n  const texture2 = createTexture(\n    gl,\n    gl.RGBA8,\n    outputWidth,\n    outputHeight,\n    gl.NEAREST,\n    gl.LINEAR\n  )\n\n  const frameBuffer1 = gl.createFramebuffer()\n  gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer1)\n  gl.framebufferTexture2D(\n    gl.FRAMEBUFFER,\n    gl.COLOR_ATTACHMENT0,\n    gl.TEXTURE_2D,\n    texture1,\n    0\n  )\n\n  const frameBuffer2 = gl.createFramebuffer()\n  gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer2)\n  gl.framebufferTexture2D(\n    gl.FRAMEBUFFER,\n    gl.COLOR_ATTACHMENT0,\n    gl.TEXTURE_2D,\n    texture2,\n    0\n  )\n\n  gl.useProgram(program)\n  gl.uniform1i(personMaskLocation, 1)\n\n  function render() {\n    gl.viewport(0, 0, outputWidth, outputHeight)\n    gl.useProgram(program)\n    gl.uniform1i(inputFrameLocation, 0)\n    gl.activeTexture(gl.TEXTURE1)\n    gl.bindTexture(gl.TEXTURE_2D, personMaskTexture)\n\n    for (let i = 0; i < 3; i++) {\n      gl.uniform2f(texelSizeLocation, 0, texelHeight)\n      gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer1)\n      gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4)\n\n      gl.activeTexture(gl.TEXTURE2)\n      gl.bindTexture(gl.TEXTURE_2D, texture1)\n      gl.uniform1i(inputFrameLocation, 2)\n\n      gl.uniform2f(texelSizeLocation, texelWidth, 0)\n      gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer2)\n      gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4)\n\n      gl.bindTexture(gl.TEXTURE_2D, texture2)\n    }\n  }\n\n  function cleanUp() {\n    gl.deleteFramebuffer(frameBuffer2)\n    gl.deleteFramebuffer(frameBuffer1)\n    gl.deleteTexture(texture2)\n    gl.deleteTexture(texture1)\n    gl.deleteProgram(program)\n    gl.deleteShader(fragmentShader)\n  }\n\n  return {\n    render,\n    cleanUp,\n  }\n}\n\nfunction buildBlendPass(\n  gl: WebGL2RenderingContext,\n  positionBuffer: WebGLBuffer,\n  texCoordBuffer: WebGLBuffer,\n  canvas: HTMLCanvasElement\n) {\n  const vertexShaderSource = glsl`#version 300 es\n\n    in vec2 a_position;\n    in vec2 a_texCoord;\n\n    out vec2 v_texCoord;\n\n    void main() {\n      // Flipping Y is required when rendering to canvas\n      gl_Position = vec4(a_position * vec2(1.0, -1.0), 0.0, 1.0);\n      v_texCoord = a_texCoord;\n    }\n  `\n\n  const fragmentShaderSource = glsl`#version 300 es\n\n    precision highp float;\n\n    uniform sampler2D u_inputFrame;\n    uniform sampler2D u_personMask;\n    uniform sampler2D u_blurredInputFrame;\n    uniform vec2 u_coverage;\n\n    in vec2 v_texCoord;\n\n    out vec4 outColor;\n\n    void main() {\n      vec3 color = texture(u_inputFrame, v_texCoord).rgb;\n      vec3 blurredColor = texture(u_blurredInputFrame, v_texCoord).rgb;\n      float personMask = texture(u_personMask, v_texCoord).a;\n      personMask = smoothstep(u_coverage.x, u_coverage.y, personMask);\n      outColor = vec4(mix(blurredColor, color, personMask), 1.0);\n    }\n  `\n\n  const { width: outputWidth, height: outputHeight } = canvas\n\n  const vertexShader = compileShader(gl, gl.VERTEX_SHADER, vertexShaderSource)\n  const fragmentShader = compileShader(\n    gl,\n    gl.FRAGMENT_SHADER,\n    fragmentShaderSource\n  )\n  const program = createPiplelineStageProgram(\n    gl,\n    vertexShader,\n    fragmentShader,\n    positionBuffer,\n    texCoordBuffer\n  )\n  const inputFrameLocation = gl.getUniformLocation(program, 'u_inputFrame')\n  const personMaskLocation = gl.getUniformLocation(program, 'u_personMask')\n  const blurredInputFrame = gl.getUniformLocation(\n    program,\n    'u_blurredInputFrame'\n  )\n  const coverageLocation = gl.getUniformLocation(program, 'u_coverage')\n\n  gl.useProgram(program)\n  gl.uniform1i(inputFrameLocation, 0)\n  gl.uniform1i(personMaskLocation, 1)\n  gl.uniform1i(blurredInputFrame, 2)\n  gl.uniform2f(coverageLocation, 0, 1)\n\n  function render() {\n    gl.viewport(0, 0, outputWidth, outputHeight)\n    gl.useProgram(program)\n    gl.bindFramebuffer(gl.FRAMEBUFFER, null)\n    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4)\n  }\n\n  function updateCoverage(coverage: [number, number]) {\n    gl.useProgram(program)\n    gl.uniform2f(coverageLocation, coverage[0], coverage[1])\n  }\n\n  function cleanUp() {\n    gl.deleteProgram(program)\n    gl.deleteShader(fragmentShader)\n    gl.deleteShader(vertexShader)\n  }\n\n  return {\n    render,\n    updateCoverage,\n    cleanUp,\n  }\n}\n","import {\n  inputResolutions,\n  SegmentationConfig,\n} from '../../core/helpers/segmentationHelper'\nimport { TFLite } from '../../core/hooks/useTFLite'\nimport {\n  compileShader,\n  createPiplelineStageProgram,\n  createTexture,\n  glsl,\n  readPixelsAsync,\n} from '../helpers/webglHelper'\n\nexport function buildResizingStage(\n  gl: WebGL2RenderingContext,\n  vertexShader: WebGLShader,\n  positionBuffer: WebGLBuffer,\n  texCoordBuffer: WebGLBuffer,\n  segmentationConfig: SegmentationConfig,\n  tflite: TFLite\n) {\n  const fragmentShaderSource = glsl`#version 300 es\n\n    precision highp float;\n\n    uniform sampler2D u_inputFrame;\n\n    in vec2 v_texCoord;\n\n    out vec4 outColor;\n\n    void main() {\n      outColor = texture(u_inputFrame, v_texCoord);\n    }\n  `\n\n  // TFLite memory will be accessed as float32\n  const tfliteInputMemoryOffset = tflite._getInputMemoryOffset() / 4\n\n  const [outputWidth, outputHeight] = inputResolutions[\n    segmentationConfig.inputResolution\n  ]\n  const outputPixelCount = outputWidth * outputHeight\n\n  const fragmentShader = compileShader(\n    gl,\n    gl.FRAGMENT_SHADER,\n    fragmentShaderSource\n  )\n  const program = createPiplelineStageProgram(\n    gl,\n    vertexShader,\n    fragmentShader,\n    positionBuffer,\n    texCoordBuffer\n  )\n  const inputFrameLocation = gl.getUniformLocation(program, 'u_inputFrame')\n  const outputTexture = createTexture(gl, gl.RGBA8, outputWidth, outputHeight)\n\n  const frameBuffer = gl.createFramebuffer()\n  gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer)\n  gl.framebufferTexture2D(\n    gl.FRAMEBUFFER,\n    gl.COLOR_ATTACHMENT0,\n    gl.TEXTURE_2D,\n    outputTexture,\n    0\n  )\n  const outputPixels = new Uint8Array(outputPixelCount * 4)\n\n  gl.useProgram(program)\n  gl.uniform1i(inputFrameLocation, 0)\n\n  function render() {\n    gl.viewport(0, 0, outputWidth, outputHeight)\n    gl.useProgram(program)\n    gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer)\n    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4)\n\n    // Downloads pixels asynchronously from GPU while rendering the current frame\n    readPixelsAsync(\n      gl,\n      0,\n      0,\n      outputWidth,\n      outputHeight,\n      gl.RGBA,\n      gl.UNSIGNED_BYTE,\n      outputPixels\n    )\n\n    for (let i = 0; i < outputPixelCount; i++) {\n      const tfliteIndex = tfliteInputMemoryOffset + i * 3\n      const outputIndex = i * 4\n      tflite.HEAPF32[tfliteIndex] = outputPixels[outputIndex] / 255\n      tflite.HEAPF32[tfliteIndex + 1] = outputPixels[outputIndex + 1] / 255\n      tflite.HEAPF32[tfliteIndex + 2] = outputPixels[outputIndex + 2] / 255\n    }\n  }\n\n  function cleanUp() {\n    gl.deleteFramebuffer(frameBuffer)\n    gl.deleteTexture(outputTexture)\n    gl.deleteProgram(program)\n    gl.deleteShader(fragmentShader)\n  }\n\n  return { render, cleanUp }\n}\n","import { BackgroundConfig } from '../../core/helpers/backgroundHelper'\nimport { PostProcessingConfig } from '../../core/helpers/postProcessingHelper'\nimport {\n  inputResolutions,\n  SegmentationConfig,\n} from '../../core/helpers/segmentationHelper'\nimport { SourcePlayback } from '../../core/helpers/sourceHelper'\nimport { TFLite } from '../../core/hooks/useTFLite'\nimport { compileShader, createTexture, glsl } from '../helpers/webglHelper'\nimport {\n  BackgroundBlurStage,\n  buildBackgroundBlurStage,\n} from './backgroundBlurStage'\nimport {\n  BackgroundImageStage,\n  buildBackgroundImageStage,\n} from './backgroundImageStage'\nimport { buildJointBilateralFilterStage } from './jointBilateralFilterStage'\nimport { buildLoadSegmentationStage } from './loadSegmentationStage'\nimport { buildResizingStage } from './resizingStage'\nimport { buildSoftmaxStage } from './softmaxStage'\n\nexport function buildWebGL2Pipeline(\n  sourcePlayback: SourcePlayback,\n  backgroundImage: HTMLImageElement | null,\n  backgroundConfig: BackgroundConfig,\n  segmentationConfig: SegmentationConfig,\n  canvas: HTMLCanvasElement,\n  tflite: TFLite,\n  addFrameEvent: () => void\n) {\n  const vertexShaderSource = glsl`#version 300 es\n\n    in vec2 a_position;\n    in vec2 a_texCoord;\n\n    out vec2 v_texCoord;\n\n    void main() {\n      gl_Position = vec4(a_position, 0.0, 1.0);\n      v_texCoord = a_texCoord;\n    }\n  `\n\n  const { width: frameWidth, height: frameHeight } = sourcePlayback\n  const [segmentationWidth, segmentationHeight] = inputResolutions[\n    segmentationConfig.inputResolution\n  ]\n\n  const gl = canvas.getContext('webgl2')!\n\n  const vertexShader = compileShader(gl, gl.VERTEX_SHADER, vertexShaderSource)\n\n  const vertexArray = gl.createVertexArray()\n  gl.bindVertexArray(vertexArray)\n\n  const positionBuffer = gl.createBuffer()!\n  gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer)\n  gl.bufferData(\n    gl.ARRAY_BUFFER,\n    new Float32Array([-1.0, -1.0, 1.0, -1.0, -1.0, 1.0, 1.0, 1.0]),\n    gl.STATIC_DRAW\n  )\n\n  const texCoordBuffer = gl.createBuffer()!\n  gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer)\n  gl.bufferData(\n    gl.ARRAY_BUFFER,\n    new Float32Array([0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 1.0, 1.0]),\n    gl.STATIC_DRAW\n  )\n\n  // We don't use texStorage2D here because texImage2D seems faster\n  // to upload video texture than texSubImage2D even though the latter\n  // is supposed to be the recommended way:\n  // https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/WebGL_best_practices#use_texstorage_to_create_textures\n  const inputFrameTexture = gl.createTexture()\n  gl.bindTexture(gl.TEXTURE_2D, inputFrameTexture)\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE)\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE)\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST)\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST)\n\n  // TODO Rename segmentation and person mask to be more specific\n  const segmentationTexture = createTexture(\n    gl,\n    gl.RGBA8,\n    segmentationWidth,\n    segmentationHeight\n  )!\n  const personMaskTexture = createTexture(\n    gl,\n    gl.RGBA8,\n    frameWidth,\n    frameHeight\n  )!\n\n  const resizingStage = buildResizingStage(\n    gl,\n    vertexShader,\n    positionBuffer,\n    texCoordBuffer,\n    segmentationConfig,\n    tflite\n  )\n  const loadSegmentationStage =\n    segmentationConfig.model === 'meet'\n      ? buildSoftmaxStage(\n          gl,\n          vertexShader,\n          positionBuffer,\n          texCoordBuffer,\n          segmentationConfig,\n          tflite,\n          segmentationTexture\n        )\n      : buildLoadSegmentationStage(\n          gl,\n          vertexShader,\n          positionBuffer,\n          texCoordBuffer,\n          segmentationConfig,\n          tflite,\n          segmentationTexture\n        )\n  const jointBilateralFilterStage = buildJointBilateralFilterStage(\n    gl,\n    vertexShader,\n    positionBuffer,\n    texCoordBuffer,\n    segmentationTexture,\n    segmentationConfig,\n    personMaskTexture,\n    canvas\n  )\n  const backgroundStage =\n    backgroundConfig.type === 'blur'\n      ? buildBackgroundBlurStage(\n          gl,\n          vertexShader,\n          positionBuffer,\n          texCoordBuffer,\n          personMaskTexture,\n          canvas\n        )\n      : buildBackgroundImageStage(\n          gl,\n          positionBuffer,\n          texCoordBuffer,\n          personMaskTexture,\n          backgroundImage,\n          canvas\n        )\n\n  async function render() {\n    gl.clearColor(0, 0, 0, 0)\n    gl.clear(gl.COLOR_BUFFER_BIT)\n\n    gl.activeTexture(gl.TEXTURE0)\n    gl.bindTexture(gl.TEXTURE_2D, inputFrameTexture)\n\n    // texImage2D seems faster than texSubImage2D to upload\n    // video texture\n    gl.texImage2D(\n      gl.TEXTURE_2D,\n      0,\n      gl.RGBA,\n      gl.RGBA,\n      gl.UNSIGNED_BYTE,\n      sourcePlayback.htmlElement\n    )\n\n    gl.bindVertexArray(vertexArray)\n\n    resizingStage.render()\n\n    addFrameEvent()\n\n    tflite._runInference()\n\n    addFrameEvent()\n\n    loadSegmentationStage.render()\n    jointBilateralFilterStage.render()\n    backgroundStage.render()\n  }\n\n  function updatePostProcessingConfig(\n    postProcessingConfig: PostProcessingConfig\n  ) {\n    jointBilateralFilterStage.updateSigmaSpace(\n      postProcessingConfig.jointBilateralFilter.sigmaSpace\n    )\n    jointBilateralFilterStage.updateSigmaColor(\n      postProcessingConfig.jointBilateralFilter.sigmaColor\n    )\n\n    if (backgroundConfig.type === 'image') {\n      const backgroundImageStage = backgroundStage as BackgroundImageStage\n      backgroundImageStage.updateCoverage(postProcessingConfig.coverage)\n      backgroundImageStage.updateLightWrapping(\n        postProcessingConfig.lightWrapping\n      )\n      backgroundImageStage.updateBlendMode(postProcessingConfig.blendMode)\n    } else if (backgroundConfig.type === 'blur') {\n      const backgroundBlurStage = backgroundStage as BackgroundBlurStage\n      backgroundBlurStage.updateCoverage(postProcessingConfig.coverage)\n    } else {\n      // TODO Handle no background in a separate pipeline path\n      const backgroundImageStage = backgroundStage as BackgroundImageStage\n      backgroundImageStage.updateCoverage([0, 0.9999])\n      backgroundImageStage.updateLightWrapping(0)\n    }\n  }\n\n  function cleanUp() {\n    backgroundStage.cleanUp()\n    jointBilateralFilterStage.cleanUp()\n    loadSegmentationStage.cleanUp()\n    resizingStage.cleanUp()\n\n    gl.deleteTexture(personMaskTexture)\n    gl.deleteTexture(segmentationTexture)\n    gl.deleteTexture(inputFrameTexture)\n    gl.deleteBuffer(texCoordBuffer)\n    gl.deleteBuffer(positionBuffer)\n    gl.deleteVertexArray(vertexArray)\n    gl.deleteShader(vertexShader)\n  }\n\n  return { render, updatePostProcessingConfig, cleanUp }\n}\n","import {\n  inputResolutions,\n  SegmentationConfig,\n} from '../../core/helpers/segmentationHelper'\nimport { TFLite } from '../../core/hooks/useTFLite'\nimport {\n  compileShader,\n  createPiplelineStageProgram,\n  createTexture,\n  glsl,\n} from '../helpers/webglHelper'\n\nexport function buildSoftmaxStage(\n  gl: WebGL2RenderingContext,\n  vertexShader: WebGLShader,\n  positionBuffer: WebGLBuffer,\n  texCoordBuffer: WebGLBuffer,\n  segmentationConfig: SegmentationConfig,\n  tflite: TFLite,\n  outputTexture: WebGLTexture\n) {\n  const fragmentShaderSource = glsl`#version 300 es\n\n    precision highp float;\n\n    uniform sampler2D u_inputSegmentation;\n\n    in vec2 v_texCoord;\n\n    out vec4 outColor;\n\n    void main() {\n      vec2 segmentation = texture(u_inputSegmentation, v_texCoord).rg;\n      float shift = max(segmentation.r, segmentation.g);\n      float backgroundExp = exp(segmentation.r - shift);\n      float personExp = exp(segmentation.g - shift);\n      outColor = vec4(vec3(0.0), personExp / (backgroundExp + personExp));\n    }\n  `\n\n  // TFLite memory will be accessed as float32\n  const tfliteOutputMemoryOffset = tflite._getOutputMemoryOffset() / 4\n\n  const [segmentationWidth, segmentationHeight] = inputResolutions[\n    segmentationConfig.inputResolution\n  ]\n\n  const fragmentShader = compileShader(\n    gl,\n    gl.FRAGMENT_SHADER,\n    fragmentShaderSource\n  )\n  const program = createPiplelineStageProgram(\n    gl,\n    vertexShader,\n    fragmentShader,\n    positionBuffer,\n    texCoordBuffer\n  )\n  const inputLocation = gl.getUniformLocation(program, 'u_inputSegmentation')\n  const inputTexture = createTexture(\n    gl,\n    gl.RG32F,\n    segmentationWidth,\n    segmentationHeight\n  )\n\n  const frameBuffer = gl.createFramebuffer()\n  gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer)\n  gl.framebufferTexture2D(\n    gl.FRAMEBUFFER,\n    gl.COLOR_ATTACHMENT0,\n    gl.TEXTURE_2D,\n    outputTexture,\n    0\n  )\n\n  gl.useProgram(program)\n  gl.uniform1i(inputLocation, 1)\n\n  function render() {\n    gl.viewport(0, 0, segmentationWidth, segmentationHeight)\n    gl.useProgram(program)\n    gl.activeTexture(gl.TEXTURE1)\n    gl.bindTexture(gl.TEXTURE_2D, inputTexture)\n    gl.texSubImage2D(\n      gl.TEXTURE_2D,\n      0,\n      0,\n      0,\n      segmentationWidth,\n      segmentationHeight,\n      gl.RG,\n      gl.FLOAT,\n      tflite.HEAPF32,\n      tfliteOutputMemoryOffset\n    )\n    gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer)\n    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4)\n  }\n\n  function cleanUp() {\n    gl.deleteFramebuffer(frameBuffer)\n    gl.deleteTexture(inputTexture)\n    gl.deleteProgram(program)\n    gl.deleteShader(fragmentShader)\n  }\n\n  return { render, cleanUp }\n}\n","import {\n  inputResolutions,\n  SegmentationConfig,\n} from '../../core/helpers/segmentationHelper'\nimport { TFLite } from '../../core/hooks/useTFLite'\nimport {\n  compileShader,\n  createPiplelineStageProgram,\n  createTexture,\n  glsl,\n} from '../helpers/webglHelper'\n\nexport function buildLoadSegmentationStage(\n  gl: WebGL2RenderingContext,\n  vertexShader: WebGLShader,\n  positionBuffer: WebGLBuffer,\n  texCoordBuffer: WebGLBuffer,\n  segmentationConfig: SegmentationConfig,\n  tflite: TFLite,\n  outputTexture: WebGLTexture\n) {\n  const fragmentShaderSource = glsl`#version 300 es\n\n    precision highp float;\n\n    uniform sampler2D u_inputSegmentation;\n\n    in vec2 v_texCoord;\n\n    out vec4 outColor;\n\n    void main() {\n      float segmentation = texture(u_inputSegmentation, v_texCoord).r;\n      outColor = vec4(vec3(0.0), segmentation);\n    }\n  `\n\n  // TFLite memory will be accessed as float32\n  const tfliteOutputMemoryOffset = tflite._getOutputMemoryOffset() / 4\n\n  const [segmentationWidth, segmentationHeight] = inputResolutions[\n    segmentationConfig.inputResolution\n  ]\n\n  const fragmentShader = compileShader(\n    gl,\n    gl.FRAGMENT_SHADER,\n    fragmentShaderSource\n  )\n  const program = createPiplelineStageProgram(\n    gl,\n    vertexShader,\n    fragmentShader,\n    positionBuffer,\n    texCoordBuffer\n  )\n  const inputLocation = gl.getUniformLocation(program, 'u_inputSegmentation')\n  const inputTexture = createTexture(\n    gl,\n    gl.R32F,\n    segmentationWidth,\n    segmentationHeight\n  )\n\n  const frameBuffer = gl.createFramebuffer()\n  gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer)\n  gl.framebufferTexture2D(\n    gl.FRAMEBUFFER,\n    gl.COLOR_ATTACHMENT0,\n    gl.TEXTURE_2D,\n    outputTexture,\n    0\n  )\n\n  gl.useProgram(program)\n  gl.uniform1i(inputLocation, 1)\n\n  function render() {\n    gl.viewport(0, 0, segmentationWidth, segmentationHeight)\n    gl.useProgram(program)\n    gl.activeTexture(gl.TEXTURE1)\n    gl.bindTexture(gl.TEXTURE_2D, inputTexture)\n    gl.texSubImage2D(\n      gl.TEXTURE_2D,\n      0,\n      0,\n      0,\n      segmentationWidth,\n      segmentationHeight,\n      gl.RED,\n      gl.FLOAT,\n      tflite.HEAPF32,\n      tfliteOutputMemoryOffset\n    )\n    gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer)\n    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4)\n  }\n\n  function cleanUp() {\n    gl.deleteFramebuffer(frameBuffer)\n    gl.deleteTexture(inputTexture)\n    gl.deleteProgram(program)\n    gl.deleteShader(fragmentShader)\n  }\n\n  return { render, cleanUp }\n}\n","import {\n  inputResolutions,\n  SegmentationConfig,\n} from '../../core/helpers/segmentationHelper'\nimport {\n  compileShader,\n  createPiplelineStageProgram,\n  glsl,\n} from '../helpers/webglHelper'\n\nexport function buildJointBilateralFilterStage(\n  gl: WebGL2RenderingContext,\n  vertexShader: WebGLShader,\n  positionBuffer: WebGLBuffer,\n  texCoordBuffer: WebGLBuffer,\n  inputTexture: WebGLTexture,\n  segmentationConfig: SegmentationConfig,\n  outputTexture: WebGLTexture,\n  canvas: HTMLCanvasElement\n) {\n  const fragmentShaderSource = glsl`#version 300 es\n\n    precision highp float;\n\n    uniform sampler2D u_inputFrame;\n    uniform sampler2D u_segmentationMask;\n    uniform vec2 u_texelSize;\n    uniform float u_step;\n    uniform float u_radius;\n    uniform float u_offset;\n    uniform float u_sigmaTexel;\n    uniform float u_sigmaColor;\n\n    in vec2 v_texCoord;\n\n    out vec4 outColor;\n\n    float gaussian(float x, float sigma) {\n      float coeff = -0.5 / (sigma * sigma * 4.0 + 1.0e-6);\n      return exp((x * x) * coeff);\n    }\n\n    void main() {\n      vec2 centerCoord = v_texCoord;\n      vec3 centerColor = texture(u_inputFrame, centerCoord).rgb;\n      float newVal = 0.0;\n\n      float spaceWeight = 0.0;\n      float colorWeight = 0.0;\n      float totalWeight = 0.0;\n\n      // Subsample kernel space.\n      for (float i = -u_radius + u_offset; i <= u_radius; i += u_step) {\n        for (float j = -u_radius + u_offset; j <= u_radius; j += u_step) {\n          vec2 shift = vec2(j, i) * u_texelSize;\n          vec2 coord = vec2(centerCoord + shift);\n          vec3 frameColor = texture(u_inputFrame, coord).rgb;\n          float outVal = texture(u_segmentationMask, coord).a;\n\n          spaceWeight = gaussian(distance(centerCoord, coord), u_sigmaTexel);\n          colorWeight = gaussian(distance(centerColor, frameColor), u_sigmaColor);\n          totalWeight += spaceWeight * colorWeight;\n\n          newVal += spaceWeight * colorWeight * outVal;\n        }\n      }\n      newVal /= totalWeight;\n\n      outColor = vec4(vec3(0.0), newVal);\n    }\n  `\n\n  const [segmentationWidth, segmentationHeight] = inputResolutions[\n    segmentationConfig.inputResolution\n  ]\n  const { width: outputWidth, height: outputHeight } = canvas\n  const texelWidth = 1 / outputWidth\n  const texelHeight = 1 / outputHeight\n\n  const fragmentShader = compileShader(\n    gl,\n    gl.FRAGMENT_SHADER,\n    fragmentShaderSource\n  )\n  const program = createPiplelineStageProgram(\n    gl,\n    vertexShader,\n    fragmentShader,\n    positionBuffer,\n    texCoordBuffer\n  )\n  const inputFrameLocation = gl.getUniformLocation(program, 'u_inputFrame')\n  const segmentationMaskLocation = gl.getUniformLocation(\n    program,\n    'u_segmentationMask'\n  )\n  const texelSizeLocation = gl.getUniformLocation(program, 'u_texelSize')\n  const stepLocation = gl.getUniformLocation(program, 'u_step')\n  const radiusLocation = gl.getUniformLocation(program, 'u_radius')\n  const offsetLocation = gl.getUniformLocation(program, 'u_offset')\n  const sigmaTexelLocation = gl.getUniformLocation(program, 'u_sigmaTexel')\n  const sigmaColorLocation = gl.getUniformLocation(program, 'u_sigmaColor')\n\n  const frameBuffer = gl.createFramebuffer()\n  gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer)\n  gl.framebufferTexture2D(\n    gl.FRAMEBUFFER,\n    gl.COLOR_ATTACHMENT0,\n    gl.TEXTURE_2D,\n    outputTexture,\n    0\n  )\n\n  gl.useProgram(program)\n  gl.uniform1i(inputFrameLocation, 0)\n  gl.uniform1i(segmentationMaskLocation, 1)\n  gl.uniform2f(texelSizeLocation, texelWidth, texelHeight)\n\n  // Ensures default values are configured to prevent infinite\n  // loop in fragment shader\n  updateSigmaSpace(0)\n  updateSigmaColor(0)\n\n  function render() {\n    gl.viewport(0, 0, outputWidth, outputHeight)\n    gl.useProgram(program)\n    gl.activeTexture(gl.TEXTURE1)\n    gl.bindTexture(gl.TEXTURE_2D, inputTexture)\n    gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer)\n    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4)\n  }\n\n  function updateSigmaSpace(sigmaSpace: number) {\n    sigmaSpace *= Math.max(\n      outputWidth / segmentationWidth,\n      outputHeight / segmentationHeight\n    )\n\n    const kSparsityFactor = 0.66 // Higher is more sparse.\n    const sparsity = Math.max(1, Math.sqrt(sigmaSpace) * kSparsityFactor)\n    const step = sparsity\n    const radius = sigmaSpace\n    const offset = step > 1 ? step * 0.5 : 0\n    const sigmaTexel = Math.max(texelWidth, texelHeight) * sigmaSpace\n\n    gl.useProgram(program)\n    gl.uniform1f(stepLocation, step)\n    gl.uniform1f(radiusLocation, radius)\n    gl.uniform1f(offsetLocation, offset)\n    gl.uniform1f(sigmaTexelLocation, sigmaTexel)\n  }\n\n  function updateSigmaColor(sigmaColor: number) {\n    gl.useProgram(program)\n    gl.uniform1f(sigmaColorLocation, sigmaColor)\n  }\n\n  function cleanUp() {\n    gl.deleteFramebuffer(frameBuffer)\n    gl.deleteProgram(program)\n    gl.deleteShader(fragmentShader)\n  }\n\n  return { render, updateSigmaSpace, updateSigmaColor, cleanUp }\n}\n","import { BlendMode } from '../../core/helpers/postProcessingHelper'\nimport {\n  compileShader,\n  createPiplelineStageProgram,\n  createTexture,\n  glsl,\n} from '../helpers/webglHelper'\n\nexport type BackgroundImageStage = {\n  render(): void\n  updateCoverage(coverage: [number, number]): void\n  updateLightWrapping(lightWrapping: number): void\n  updateBlendMode(blendMode: BlendMode): void\n  cleanUp(): void\n}\n\nexport function buildBackgroundImageStage(\n  gl: WebGL2RenderingContext,\n  positionBuffer: WebGLBuffer,\n  texCoordBuffer: WebGLBuffer,\n  personMaskTexture: WebGLTexture,\n  backgroundImage: HTMLImageElement | null,\n  canvas: HTMLCanvasElement\n): BackgroundImageStage {\n  const vertexShaderSource = glsl`#version 300 es\n\n    uniform vec2 u_backgroundScale;\n    uniform vec2 u_backgroundOffset;\n\n    in vec2 a_position;\n    in vec2 a_texCoord;\n\n    out vec2 v_texCoord;\n    out vec2 v_backgroundCoord;\n\n    void main() {\n      // Flipping Y is required when rendering to canvas\n      gl_Position = vec4(a_position * vec2(1.0, -1.0), 0.0, 1.0);\n      v_texCoord = a_texCoord;\n      v_backgroundCoord = a_texCoord * u_backgroundScale + u_backgroundOffset;\n    }\n  `\n\n  const fragmentShaderSource = glsl`#version 300 es\n\n    precision highp float;\n\n    uniform sampler2D u_inputFrame;\n    uniform sampler2D u_personMask;\n    uniform sampler2D u_background;\n    uniform vec2 u_coverage;\n    uniform float u_lightWrapping;\n    uniform float u_blendMode;\n\n    in vec2 v_texCoord;\n    in vec2 v_backgroundCoord;\n\n    out vec4 outColor;\n\n    vec3 screen(vec3 a, vec3 b) {\n      return 1.0 - (1.0 - a) * (1.0 - b);\n    }\n\n    vec3 linearDodge(vec3 a, vec3 b) {\n      return a + b;\n    }\n\n    void main() {\n      vec3 frameColor = texture(u_inputFrame, v_texCoord).rgb;\n      vec3 backgroundColor = texture(u_background, v_backgroundCoord).rgb;\n      float personMask = texture(u_personMask, v_texCoord).a;\n      float lightWrapMask = 1.0 - max(0.0, personMask - u_coverage.y) / (1.0 - u_coverage.y);\n      vec3 lightWrap = u_lightWrapping * lightWrapMask * backgroundColor;\n      frameColor = u_blendMode * linearDodge(frameColor, lightWrap) +\n        (1.0 - u_blendMode) * screen(frameColor, lightWrap);\n      personMask = smoothstep(u_coverage.x, u_coverage.y, personMask);\n      outColor = vec4(frameColor * personMask + backgroundColor * (1.0 - personMask), 1.0);\n    }\n  `\n\n  const { width: outputWidth, height: outputHeight } = canvas\n  const outputRatio = outputWidth / outputHeight\n\n  const vertexShader = compileShader(gl, gl.VERTEX_SHADER, vertexShaderSource)\n  const fragmentShader = compileShader(\n    gl,\n    gl.FRAGMENT_SHADER,\n    fragmentShaderSource\n  )\n  const program = createPiplelineStageProgram(\n    gl,\n    vertexShader,\n    fragmentShader,\n    positionBuffer,\n    texCoordBuffer\n  )\n  const backgroundScaleLocation = gl.getUniformLocation(\n    program,\n    'u_backgroundScale'\n  )\n  const backgroundOffsetLocation = gl.getUniformLocation(\n    program,\n    'u_backgroundOffset'\n  )\n  const inputFrameLocation = gl.getUniformLocation(program, 'u_inputFrame')\n  const personMaskLocation = gl.getUniformLocation(program, 'u_personMask')\n  const backgroundLocation = gl.getUniformLocation(program, 'u_background')\n  const coverageLocation = gl.getUniformLocation(program, 'u_coverage')\n  const lightWrappingLocation = gl.getUniformLocation(\n    program,\n    'u_lightWrapping'\n  )\n  const blendModeLocation = gl.getUniformLocation(program, 'u_blendMode')\n\n  gl.useProgram(program)\n  gl.uniform2f(backgroundScaleLocation, 1, 1)\n  gl.uniform2f(backgroundOffsetLocation, 0, 0)\n  gl.uniform1i(inputFrameLocation, 0)\n  gl.uniform1i(personMaskLocation, 1)\n  gl.uniform2f(coverageLocation, 0, 1)\n  gl.uniform1f(lightWrappingLocation, 0)\n  gl.uniform1f(blendModeLocation, 0)\n\n  let backgroundTexture: WebGLTexture | null = null\n  // TODO Find a better to handle background being loaded\n  if (backgroundImage?.complete) {\n    updateBackgroundImage(backgroundImage)\n  } else if (backgroundImage) {\n    backgroundImage.onload = () => {\n      updateBackgroundImage(backgroundImage)\n    }\n  }\n\n  function render() {\n    gl.viewport(0, 0, outputWidth, outputHeight)\n    gl.useProgram(program)\n    gl.activeTexture(gl.TEXTURE1)\n    gl.bindTexture(gl.TEXTURE_2D, personMaskTexture)\n    if (backgroundTexture !== null) {\n      gl.activeTexture(gl.TEXTURE2)\n      gl.bindTexture(gl.TEXTURE_2D, backgroundTexture)\n      // TODO Handle correctly the background not loaded yet\n      gl.uniform1i(backgroundLocation, 2)\n    }\n    gl.bindFramebuffer(gl.FRAMEBUFFER, null)\n    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4)\n  }\n\n  function updateBackgroundImage(backgroundImage: HTMLImageElement) {\n    backgroundTexture = createTexture(\n      gl,\n      gl.RGBA8,\n      backgroundImage.naturalWidth,\n      backgroundImage.naturalHeight,\n      gl.LINEAR,\n      gl.LINEAR\n    )\n    gl.texSubImage2D(\n      gl.TEXTURE_2D,\n      0,\n      0,\n      0,\n      backgroundImage.naturalWidth,\n      backgroundImage.naturalHeight,\n      gl.RGBA,\n      gl.UNSIGNED_BYTE,\n      backgroundImage\n    )\n\n    let xOffset = 0\n    let yOffset = 0\n    let backgroundWidth = backgroundImage.naturalWidth\n    let backgroundHeight = backgroundImage.naturalHeight\n    const backgroundRatio = backgroundWidth / backgroundHeight\n    if (backgroundRatio < outputRatio) {\n      backgroundHeight = backgroundWidth / outputRatio\n      yOffset = (backgroundImage.naturalHeight - backgroundHeight) / 2\n    } else {\n      backgroundWidth = backgroundHeight * outputRatio\n      xOffset = (backgroundImage.naturalWidth - backgroundWidth) / 2\n    }\n\n    const xScale = backgroundWidth / backgroundImage.naturalWidth\n    const yScale = backgroundHeight / backgroundImage.naturalHeight\n    xOffset /= backgroundImage.naturalWidth\n    yOffset /= backgroundImage.naturalHeight\n\n    gl.uniform2f(backgroundScaleLocation, xScale, yScale)\n    gl.uniform2f(backgroundOffsetLocation, xOffset, yOffset)\n  }\n\n  function updateCoverage(coverage: [number, number]) {\n    gl.useProgram(program)\n    gl.uniform2f(coverageLocation, coverage[0], coverage[1])\n  }\n\n  function updateLightWrapping(lightWrapping: number) {\n    gl.useProgram(program)\n    gl.uniform1f(lightWrappingLocation, lightWrapping)\n  }\n\n  function updateBlendMode(blendMode: BlendMode) {\n    gl.useProgram(program)\n    gl.uniform1f(blendModeLocation, blendMode === 'screen' ? 0 : 1)\n  }\n\n  function cleanUp() {\n    gl.deleteTexture(backgroundTexture)\n    gl.deleteProgram(program)\n    gl.deleteShader(fragmentShader)\n    gl.deleteShader(vertexShader)\n  }\n\n  return {\n    render,\n    updateCoverage,\n    updateLightWrapping,\n    updateBlendMode,\n    cleanUp,\n  }\n}\n","import { BodyPix } from '@tensorflow-models/body-pix'\nimport { useEffect, useRef, useState } from 'react'\nimport { buildCanvas2dPipeline } from '../../pipelines/canvas2d/canvas2dPipeline'\nimport { buildWebGL2Pipeline } from '../../pipelines/webgl2/webgl2Pipeline'\nimport { BackgroundConfig } from '../helpers/backgroundHelper'\nimport { RenderingPipeline } from '../helpers/renderingPipelineHelper'\nimport { SegmentationConfig } from '../helpers/segmentationHelper'\nimport { SourcePlayback } from '../helpers/sourceHelper'\nimport { TFLite } from './useTFLite'\n\nfunction useRenderingPipeline(\n  sourcePlayback: SourcePlayback,\n  backgroundConfig: BackgroundConfig,\n  segmentationConfig: SegmentationConfig,\n  bodyPix: BodyPix,\n  tflite: TFLite\n) {\n  const [pipeline, setPipeline] = useState<RenderingPipeline | null>(null)\n  const backgroundImageRef = useRef<HTMLImageElement>(null)\n  const canvasRef = useRef<HTMLCanvasElement>(null!)\n  const [fps, setFps] = useState(0)\n  const [durations, setDurations] = useState<number[]>([])\n\n  useEffect(() => {\n    // The useEffect cleanup function is not enough to stop\n    // the rendering loop when the framerate is low\n    let shouldRender = true\n\n    let previousTime = 0\n    let beginTime = 0\n    let eventCount = 0\n    let frameCount = 0\n    const frameDurations: number[] = []\n\n    let renderRequestId: number\n\n    const newPipeline =\n      segmentationConfig.pipeline === 'webgl2'\n        ? buildWebGL2Pipeline(\n          sourcePlayback,\n          backgroundImageRef.current,\n          backgroundConfig,\n          segmentationConfig,\n          canvasRef.current,\n          tflite,\n          addFrameEvent\n        )\n        : buildCanvas2dPipeline(\n          sourcePlayback,\n          backgroundConfig,\n          segmentationConfig,\n          canvasRef.current,\n          bodyPix,\n          tflite,\n          addFrameEvent\n        )\n\n    async function render() {\n      if (!shouldRender) {\n        return\n      }\n      beginFrame()\n      await newPipeline.render()\n      endFrame()\n      renderRequestId = requestAnimationFrame(render)\n    }\n\n    function beginFrame() {\n      beginTime = Date.now()\n    }\n\n    function addFrameEvent() {\n      const time = Date.now()\n      frameDurations[eventCount] = time - beginTime\n      beginTime = time\n      eventCount++\n    }\n\n    function endFrame() {\n      const time = Date.now()\n      frameDurations[eventCount] = time - beginTime\n      frameCount++\n      console.log(frameCount)\n      if (time >= previousTime + 1000) {\n        setFps((frameCount * 1000) / (time - previousTime))\n        setDurations(frameDurations)\n        previousTime = time\n        frameCount = 0\n      }\n      eventCount = 0\n    }\n\n    render()\n    console.log(\n      'Animation started:',\n      sourcePlayback,\n      backgroundConfig,\n      segmentationConfig\n    )\n\n    setPipeline(newPipeline)\n\n    return () => {\n      shouldRender = false\n      cancelAnimationFrame(renderRequestId)\n      newPipeline.cleanUp()\n      console.log(\n        'Animation stopped:',\n        sourcePlayback,\n        backgroundConfig,\n        segmentationConfig\n      )\n\n      setPipeline(null)\n    }\n  }, [sourcePlayback, backgroundConfig, segmentationConfig, bodyPix, tflite])\n\n  return {\n    pipeline,\n    backgroundImageRef,\n    canvasRef,\n    fps,\n    durations,\n  }\n}\n\nexport default useRenderingPipeline\n","import { Button } from \"@material-ui/core\"\nimport { createStyles, makeStyles, Theme } from '@material-ui/core/styles'\nimport { BodyPix } from '@tensorflow-models/body-pix'\nimport React, { useEffect } from 'react'\nimport { BackgroundConfig } from '../helpers/backgroundHelper'\nimport { PostProcessingConfig } from '../helpers/postProcessingHelper'\nimport { SegmentationConfig } from '../helpers/segmentationHelper'\nimport { SourcePlayback } from '../helpers/sourceHelper'\nimport useRenderingPipeline from '../hooks/useRenderingPipeline'\nimport { TFLite } from '../hooks/useTFLite'\n\ntype OutputViewerProps = {\n  sourcePlayback: SourcePlayback\n  backgroundConfig: BackgroundConfig\n  segmentationConfig: SegmentationConfig\n  postProcessingConfig: PostProcessingConfig\n  bodyPix: BodyPix\n  tflite: TFLite\n}\n\nfunction OutputViewer(props: OutputViewerProps) {\n  const classes = useStyles()\n\n  const {\n    pipeline,\n    backgroundImageRef,\n    canvasRef,\n    fps,\n    durations: [resizingDuration, inferenceDuration, postProcessingDuration],\n  } = useRenderingPipeline(\n    props.sourcePlayback,\n    props.backgroundConfig,\n    props.segmentationConfig,\n    props.bodyPix,\n    props.tflite\n  )\n\n  useEffect(() => {\n    if (pipeline) {\n      pipeline.updatePostProcessingConfig(props.postProcessingConfig)\n    }\n  }, [pipeline, props.postProcessingConfig])\n\n  const statDetails = [\n    `resizing ${resizingDuration}ms`,\n    `inference ${inferenceDuration}ms`,\n    `post-processing ${postProcessingDuration}ms`,\n  ]\n  const stats = `${Math.round(fps)} fps (${statDetails.join(', ')})`\n\n  const [imgSrc, setImgSrc] = React.useState<any>(null)\n  const webcamRef = React.useRef(null)\n  // const canvasRef = useRef(null)\n\n  const capture = React.useCallback(() => {\n    // const imageSrc = canvasRef.current.getScreenshot()\n    // setImgSrc(null)\n\n    let can = document.getElementById(\"canvas\");\n    let imgSrc = canvasRef.current.toDataURL();\n    setImgSrc(imgSrc);\n\n  }, [canvasRef, setImgSrc])\n\n  const handleClick = (e: any) => {\n    const img_ids = ['img1', 'img2', 'img3']\n    const id = e.target.id\n\n    const images = document.getElementsByClassName('camel')[0].childNodes\n    // for (let i = 0, j = 0; i < images.length; i++) {\n    //   let currentImgId = images[i].id\n\n    //   if (id === currentImgId) {\n    //     images[i].className = 'order2'\n    //     images[i].setAttribute('style', 'width: 20%; height: 65%;')\n    //   } else {\n    //     images[i].className = `order${++j}`\n    //     images[i].setAttribute('style', 'width: 15%; height: 50%;')\n    //     j++\n    //   }\n    // }\n  }\n\n  return (\n    <div style={{ width: '100%', height: '100vh', position: 'relative' }}>\n      <div className={`${classes.root} container`}>\n        {props.backgroundConfig.type === 'image' && (\n          <img\n            ref={backgroundImageRef}\n            className={classes.render}\n            src={props.backgroundConfig.url}\n            alt=\"\"\n            hidden={props.segmentationConfig.pipeline === 'webgl2'}\n          />\n        )}\n        <canvas\n          // The key attribute is required to create a new canvas when switching\n          // context mode\n          id=\"canvas\"\n          key={props.segmentationConfig.pipeline}\n          ref={canvasRef}\n          className={classes.render}\n          width={props.sourcePlayback.width}\n          height={props.sourcePlayback.height}\n        />\n        {/* <Typography className={classes.stats} variant=\"caption\">\n          {stats}\n        </Typography> */}\n\n        <Button\n          variant=\"contained\"\n          className=\"skip-btn\"\n        >\n          Next\n      </Button>\n      </div>\n\n\n    </div>\n  )\n}\n\nconst useStyles = makeStyles((theme: Theme) =>\n  createStyles({\n    root: {\n      flex: 1,\n      position: 'relative',\n    },\n    render: {\n      position: 'absolute',\n      width: '100%',\n      height: '100%',\n      objectFit: 'cover',\n    },\n    stats: {\n      position: 'absolute',\n      top: 0,\n      right: 0,\n      left: 0,\n      textAlign: 'center',\n      backgroundColor: 'rgba(0, 0, 0, 0.48)',\n      color: theme.palette.common.white,\n    },\n  })\n)\n\nexport default OutputViewer\n","import CircularProgress from '@material-ui/core/CircularProgress'\nimport { createStyles, makeStyles, Theme } from '@material-ui/core/styles'\nimport VideocamOffIcon from '@material-ui/icons/VideocamOff'\nimport React, { SyntheticEvent, useEffect, useRef, useState } from 'react'\nimport { SourceConfig, SourcePlayback } from '../helpers/sourceHelper'\n\ntype SourceViewerProps = {\n  sourceConfig: SourceConfig\n  onLoad: (sourcePlayback: SourcePlayback) => void\n}\n\nfunction SourceViewer(props: SourceViewerProps) {\n  const classes = useStyles()\n  const [sourceUrl, setSourceUrl] = useState<string>()\n  const [isLoading, setLoading] = useState(false)\n  const [isCameraError, setCameraError] = useState(false)\n  const videoRef = useRef<HTMLVideoElement>(null)\n\n  useEffect(() => {\n    setSourceUrl(undefined)\n    setLoading(true)\n    setCameraError(false)\n\n    // Enforces reloading the resource, otherwise\n    // onLoad event is not always dispatched and the\n    // progress indicator never disappears\n    setTimeout(() => setSourceUrl(props.sourceConfig.url))\n  }, [props.sourceConfig])\n\n  useEffect(() => {\n    async function getCameraStream() {\n      try {\n        const constraint = { video: true }\n        const stream = await navigator.mediaDevices.getUserMedia(constraint)\n        if (videoRef.current) {\n          videoRef.current.srcObject = stream\n          console.log(videoRef)\n          return\n        }\n      } catch (error) {\n        console.error('Error opening video camera.', error)\n      }\n      setLoading(false)\n      setCameraError(true)\n    }\n\n    if (props.sourceConfig.type === 'camera') {\n      getCameraStream()\n    } else if (videoRef.current) {\n      videoRef.current.srcObject = null\n    }\n  }, [props.sourceConfig])\n\n  function handleImageLoad(event: SyntheticEvent) {\n    const image = event.target as HTMLImageElement\n    props.onLoad({\n      htmlElement: image,\n      width: image.naturalWidth,\n      height: image.naturalHeight,\n    })\n    setLoading(false)\n  }\n\n  function handleVideoLoad(event: SyntheticEvent) {\n    const video = event.target as HTMLVideoElement\n    console.log(\"Handle\", video)\n    props.onLoad({\n      htmlElement: video,\n      width: video.videoWidth,\n      height: video.videoHeight,\n    })\n    setLoading(false)\n  }\n\n  return (\n    <div className={classes.root}>\n      {isLoading && <CircularProgress />}\n      {props.sourceConfig.type === 'image' ? (\n        <img\n          className={classes.sourcePlayback}\n          src={sourceUrl}\n          hidden={isLoading}\n          alt=\"\"\n          onLoad={handleImageLoad}\n        />\n      ) : isCameraError ? (\n        <VideocamOffIcon fontSize=\"large\" />\n      ) : (\n            <video\n              ref={videoRef}\n              className={classes.sourcePlayback}\n              src={sourceUrl}\n              hidden={isLoading}\n              autoPlay\n              playsInline\n              controls={false}\n              muted\n              loop\n              onLoadedData={handleVideoLoad}\n            />\n          )}\n    </div>\n  )\n}\n\nconst useStyles = makeStyles((theme: Theme) =>\n  createStyles({\n    root: {\n      position: 'relative',\n      display: 'flex',\n      justifyContent: 'center',\n      alignItems: 'center',\n\n      [theme.breakpoints.down('xs')]: {\n        width: 0,\n        overflow: 'hidden',\n      },\n\n      [theme.breakpoints.up('sm')]: {\n        flex: 1,\n        borderRightWidth: 1,\n        borderRightStyle: 'solid',\n        borderRightColor: theme.palette.divider,\n      },\n    },\n    sourcePlayback: {\n      position: 'absolute',\n      width: '100%',\n      height: '100%',\n      objectFit: 'cover',\n    },\n  })\n)\n\nexport default SourceViewer\n","import Avatar from '@material-ui/core/Avatar'\nimport Paper from '@material-ui/core/Paper'\nimport { createStyles, makeStyles, Theme } from '@material-ui/core/styles'\nimport { BodyPix } from '@tensorflow-models/body-pix'\nimport { useEffect, useState } from 'react'\nimport { BackgroundConfig } from '../helpers/backgroundHelper'\nimport { PostProcessingConfig } from '../helpers/postProcessingHelper'\nimport { SegmentationConfig } from '../helpers/segmentationHelper'\nimport { SourceConfig, SourcePlayback } from '../helpers/sourceHelper'\nimport { TFLite } from '../hooks/useTFLite'\nimport OutputViewer from './OutputViewer'\nimport SourceViewer from './SourceViewer'\n\ntype ViewerCardProps = {\n  sourceConfig: SourceConfig\n  backgroundConfig: BackgroundConfig\n  segmentationConfig: SegmentationConfig\n  postProcessingConfig: PostProcessingConfig\n  bodyPix?: BodyPix\n  tflite?: TFLite\n}\n\nfunction ViewerCard(props: ViewerCardProps) {\n  const classes = useStyles()\n  const [sourcePlayback, setSourcePlayback] = useState<SourcePlayback>()\n\n  useEffect(() => {\n    setSourcePlayback(undefined)\n  }, [props.sourceConfig])\n\n  return (\n    <Paper className={classes.root} style={{ width: '100%' }}>\n      <SourceViewer\n        sourceConfig={props.sourceConfig}\n        onLoad={setSourcePlayback}\n      />\n      {sourcePlayback && props.bodyPix && props.tflite ? (\n        <OutputViewer\n          sourcePlayback={sourcePlayback}\n          backgroundConfig={props.backgroundConfig}\n          segmentationConfig={props.segmentationConfig}\n          postProcessingConfig={props.postProcessingConfig}\n          bodyPix={props.bodyPix}\n          tflite={props.tflite}\n        />\n      ) : (\n        <div className={classes.noOutput}>\n          <Avatar className={classes.avatar} />\n        </div>\n      )}\n    </Paper>\n  )\n}\n\nconst useStyles = makeStyles((theme: Theme) => {\n  const minHeight = [`${theme.spacing(52)}px`, `100vh - ${theme.spacing(2)}px`]\n\n  return createStyles({\n    root: {\n      minHeight: `calc(min(${minHeight.join(', ')}))`,\n      display: 'flex',\n      overflow: 'hidden',\n\n      [theme.breakpoints.up('md')]: {\n        gridColumnStart: 1,\n        gridColumnEnd: 3,\n      },\n\n      [theme.breakpoints.up('lg')]: {\n        gridRowStart: 1,\n        gridRowEnd: 3,\n      },\n    },\n    noOutput: {\n      flex: 1,\n      display: 'flex',\n      justifyContent: 'center',\n      alignItems: 'center',\n    },\n    avatar: {\n      width: theme.spacing(20),\n      height: theme.spacing(20),\n    },\n  })\n})\n\nexport default ViewerCard\n","export type BackgroundConfig = {\n  type: 'none' | 'blur' | 'image'\n  url?: string\n}\n\nexport const backgroundImageUrls = [\n  'asset-6',\n  'porch-691330_1280',\n  'saxon-switzerland-539418_1280',\n  'shibuyasky-4768679_1280',\n].map((imageName) => `${process.env.PUBLIC_URL}/backgrounds/${imageName}.png`)\n","import * as tfBodyPix from '@tensorflow-models/body-pix'\nimport * as tf from '@tensorflow/tfjs'\nimport { useEffect, useState } from 'react'\n\nfunction useBodyPix() {\n  const [bodyPix, setBodyPix] = useState<tfBodyPix.BodyPix>()\n\n  useEffect(() => {\n    async function loadBodyPix() {\n      console.log('Loading TensorFlow.js and BodyPix segmentation model')\n      await tf.ready()\n      setBodyPix(await tfBodyPix.load())\n      console.log('TensorFlow.js and BodyPix loaded')\n    }\n\n    loadBodyPix()\n  }, [])\n\n  return bodyPix\n}\n\nexport default useBodyPix\n","import { useEffect, useState } from 'react'\nimport {\n  getTFLiteModelFileName,\n  SegmentationConfig,\n} from '../helpers/segmentationHelper'\n\ndeclare function createTFLiteModule(): Promise<TFLite>\ndeclare function createTFLiteSIMDModule(): Promise<TFLite>\n\nexport interface TFLite extends EmscriptenModule {\n  _getModelBufferMemoryOffset(): number\n  _getInputMemoryOffset(): number\n  _getInputHeight(): number\n  _getInputWidth(): number\n  _getInputChannelCount(): number\n  _getOutputMemoryOffset(): number\n  _getOutputHeight(): number\n  _getOutputWidth(): number\n  _getOutputChannelCount(): number\n  _loadModel(bufferSize: number): number\n  _runInference(): number\n}\n\nfunction useTFLite(segmentationConfig: SegmentationConfig) {\n  const [tflite, setTFLite] = useState<TFLite>()\n  const [tfliteSIMD, setTFLiteSIMD] = useState<TFLite>()\n  const [selectedTFLite, setSelectedTFLite] = useState<TFLite>()\n  const [isSIMDSupported, setSIMDSupported] = useState(false)\n\n  useEffect(() => {\n    async function loadTFLite() {\n      createTFLiteModule().then(setTFLite)\n      try {\n        const createdTFLiteSIMD = await createTFLiteSIMDModule()\n        setTFLiteSIMD(createdTFLiteSIMD)\n        setSIMDSupported(true)\n      } catch (error) {\n        console.warn('Failed to create TFLite SIMD WebAssembly module.', error)\n      }\n    }\n\n    loadTFLite()\n  }, [])\n\n  useEffect(() => {\n    async function loadTFLiteModel() {\n      if (\n        !tflite ||\n        (isSIMDSupported && !tfliteSIMD) ||\n        (!isSIMDSupported && segmentationConfig.backend === 'wasmSimd') ||\n        (segmentationConfig.model !== 'meet' &&\n          segmentationConfig.model !== 'mlkit')\n      ) {\n        return\n      }\n\n      setSelectedTFLite(undefined)\n\n      const newSelectedTFLite =\n        segmentationConfig.backend === 'wasmSimd' ? tfliteSIMD : tflite\n\n      if (!newSelectedTFLite) {\n        throw new Error(\n          `TFLite backend unavailable: ${segmentationConfig.backend}`\n        )\n      }\n\n      const modelFileName = getTFLiteModelFileName(\n        segmentationConfig.model,\n        segmentationConfig.inputResolution\n      )\n      console.log('Loading tflite model:', modelFileName)\n\n      const modelResponse = await fetch(\n        `${process.env.PUBLIC_URL}/models/${modelFileName}.tflite`\n      )\n      const model = await modelResponse.arrayBuffer()\n      console.log('Model buffer size:', model.byteLength)\n\n      const modelBufferOffset = newSelectedTFLite._getModelBufferMemoryOffset()\n      console.log('Model buffer memory offset:', modelBufferOffset)\n      console.log('Loading model buffer...')\n      newSelectedTFLite.HEAPU8.set(new Uint8Array(model), modelBufferOffset)\n      console.log(\n        '_loadModel result:',\n        newSelectedTFLite._loadModel(model.byteLength)\n      )\n\n      console.log(\n        'Input memory offset:',\n        newSelectedTFLite._getInputMemoryOffset()\n      )\n      console.log('Input height:', newSelectedTFLite._getInputHeight())\n      console.log('Input width:', newSelectedTFLite._getInputWidth())\n      console.log('Input channels:', newSelectedTFLite._getInputChannelCount())\n\n      console.log(\n        'Output memory offset:',\n        newSelectedTFLite._getOutputMemoryOffset()\n      )\n      console.log('Output height:', newSelectedTFLite._getOutputHeight())\n      console.log('Output width:', newSelectedTFLite._getOutputWidth())\n      console.log(\n        'Output channels:',\n        newSelectedTFLite._getOutputChannelCount()\n      )\n\n      setSelectedTFLite(newSelectedTFLite)\n    }\n\n    loadTFLiteModel()\n  }, [\n    tflite,\n    tfliteSIMD,\n    isSIMDSupported,\n    segmentationConfig.model,\n    segmentationConfig.backend,\n    segmentationConfig.inputResolution,\n  ])\n\n  return { tflite: selectedTFLite, isSIMDSupported }\n}\n\nexport default useTFLite\n","import { createStyles, makeStyles, Theme } from '@material-ui/core/styles'\nimport { useEffect, useState } from 'react'\nimport './App.css'\nimport ViewerCard from './core/components/ViewerCard'\nimport {\n  BackgroundConfig,\n  backgroundImageUrls,\n} from './core/helpers/backgroundHelper'\nimport { PostProcessingConfig } from './core/helpers/postProcessingHelper'\nimport { SegmentationConfig } from './core/helpers/segmentationHelper'\nimport { SourceConfig } from './core/helpers/sourceHelper'\nimport useBodyPix from './core/hooks/useBodyPix'\nimport useTFLite from './core/hooks/useTFLite'\n\nfunction App() {\n  const classes = useStyles()\n  const [sourceConfig, setSourceConfig] = useState<SourceConfig>({\n    type: 'camera',\n  })\n  const [backgroundConfig, setBackgroundConfig] = useState<BackgroundConfig>({\n    type: 'image',\n    url: backgroundImageUrls[0],\n  })\n  const [segmentationConfig, setSegmentationConfig] =\n    useState<SegmentationConfig>({\n      model: 'meet',\n      backend: 'wasm',\n      inputResolution: '160x96',\n      pipeline: 'webgl2',\n    })\n  const [postProcessingConfig, setPostProcessingConfig] =\n    useState<PostProcessingConfig>({\n      smoothSegmentationMask: true,\n      jointBilateralFilter: { sigmaSpace: 1, sigmaColor: 0.1 },\n      coverage: [0.5, 0.75],\n      lightWrapping: 0.3,\n      blendMode: 'screen',\n    })\n  const bodyPix = useBodyPix()\n  const { tflite, isSIMDSupported } = useTFLite(segmentationConfig)\n\n  useEffect(() => {\n    setSegmentationConfig((previousSegmentationConfig) => {\n      if (previousSegmentationConfig.backend === 'wasm' && isSIMDSupported) {\n        return { ...previousSegmentationConfig, backend: 'wasmSimd' }\n      } else {\n        return previousSegmentationConfig\n      }\n    })\n  }, [isSIMDSupported])\n\n  return (\n    <div\n      className={classes.root}\n      style={{ margin: '0', width: '100%', height: '100vh' }}\n    >\n      <ViewerCard\n        sourceConfig={sourceConfig}\n        backgroundConfig={backgroundConfig}\n        segmentationConfig={segmentationConfig}\n        postProcessingConfig={postProcessingConfig}\n        bodyPix={bodyPix}\n        tflite={tflite}\n      />\n\n      {/* <BackgroundConfigCard\n        config={backgroundConfig}\n        onChange={setBackgroundConfig}\n      />\n      <PostProcessingConfigCard\n        config={postProcessingConfig}\n        pipeline={segmentationConfig.pipeline}\n        onChange={setPostProcessingConfig}\n      /> */}\n    </div>\n  )\n}\n\nconst useStyles = makeStyles((theme: Theme) =>\n  createStyles({\n    root: {\n      display: 'grid',\n\n      [theme.breakpoints.up('xs')]: {\n        margin: theme.spacing(1),\n        gap: theme.spacing(1),\n        gridTemplateColumns: '1fr',\n      },\n\n      [theme.breakpoints.up('md')]: {\n        margin: theme.spacing(2),\n        gap: theme.spacing(2),\n        gridTemplateColumns: 'repeat(2, 1fr)',\n      },\n\n      [theme.breakpoints.up('lg')]: {\n        gridTemplateColumns: 'repeat(3, 1fr)',\n      },\n    },\n    resourceSelectionCards: {\n      display: 'flex',\n      flexDirection: 'column',\n    },\n  })\n)\n\nexport default App\n","import { ReportHandler } from 'web-vitals'\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry)\n      getFID(onPerfEntry)\n      getFCP(onPerfEntry)\n      getLCP(onPerfEntry)\n      getTTFB(onPerfEntry)\n    })\n  }\n}\n\nexport default reportWebVitals\n","import CssBaseline from '@material-ui/core/CssBaseline'\nimport React from 'react'\nimport ReactDOM from 'react-dom'\nimport App from './App'\nimport reportWebVitals from './reportWebVitals'\n\nReactDOM.render(\n  <React.StrictMode>\n    <CssBaseline />\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n)\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals()\n"],"sourceRoot":""}